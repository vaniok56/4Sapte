"""
Fallback mock data for when the DeepSeek API is not available
This allows the bot to function for testing purposes
"""

import json
import logging
from typing import Dict, List

class MockDeepSeekAPI:
    """Mock DeepSeek API for testing when real API is unavailable"""
    
    def __init__(self, api_key: str, api_url: str, model: str = "mock"):
        self.api_key = api_key
        self.api_url = api_url
        self.model = model
        logging.info("ðŸ”§ Using Mock DeepSeek API for testing")
    
    async def extract_product_attributes(self, product_name: str, category: str, 
                                       subcategory: str, expected_attributes: List[str]) -> Dict:
        """
        Mock product attribute extraction with realistic responses
        """
        logging.info(f"Mock extracting attributes for: {product_name}")
        
        # Create mock data based on product name patterns
        mock_data = self._generate_mock_attributes(product_name, category, subcategory, expected_attributes)
        
        return {
            'success': True,
            'product_name': product_name,
            'category': category,
            'subcategory': subcategory,
            'attributes': mock_data,
            'confidence': 0.8,
            'note': 'Generated by Mock API for testing'
        }
    
    def _generate_mock_attributes(self, product_name: str, category: str, 
                                subcategory: str, expected_attributes: List[str]) -> Dict:
        """Generate realistic mock attributes based on product name"""
        
        attributes = {}
        product_lower = product_name.lower()
        
        # Electronics - Smartphones & Accessories
        if "iphone" in product_lower:
            mock_responses = {
                "Brand": "Apple",
                "Model": self._extract_model_from_name(product_name, "iPhone"),
                "Operating System": "iOS",
                "Storage Capacity": self._extract_storage(product_name),
                "Color": self._extract_color(product_name),
                "Screen Size": "6.1 inches" if "13" in product_name else "6.7 inches",
                "RAM": "6GB",
                "Camera Specs": "48MP Main Camera",
                "Battery Life": "Up to 22 hours video playback",
                "Connectivity (5G, Wi-Fi)": "5G, Wi-Fi 6"
            }
        elif "samsung" in product_lower or "galaxy" in product_lower:
            mock_responses = {
                "Brand": "Samsung",
                "Model": self._extract_model_from_name(product_name, "Galaxy"),
                "Operating System": "Android",
                "Storage Capacity": self._extract_storage(product_name),
                "Color": self._extract_color(product_name),
                "Screen Size": "6.8 inches",
                "RAM": "12GB",
                "Camera Specs": "108MP Triple Camera",
                "Battery Life": "5000mAh",
                "Connectivity (5G, Wi-Fi)": "5G, Wi-Fi 6E"
            }
        elif "macbook" in product_lower or "laptop" in product_lower:
            mock_responses = {
                "Brand": "Apple" if "macbook" in product_lower else "Unknown",
                "Model": self._extract_model_from_name(product_name, "MacBook"),
                "Processor": "M2 chip" if "macbook" in product_lower else "Intel i7",
                "RAM": self._extract_ram(product_name),
                "Storage Type (SSD/HDD)": "SSD",
                "Screen Size": "13.3 inches",
                "Graphics Card": "Integrated",
                "Operating System": "macOS" if "macbook" in product_lower else "Windows 11",
                "Weight": "1.4 kg",
                "Battery Life": "Up to 18 hours"
            }
        # Books & Media
        elif category == "Books & Media":
            if "harry potter" in product_lower:
                mock_responses = {
                    "Author": "J.K. Rowling",
                    "Genre": "Fantasy",
                    "Format (Hardcover, Paperback)": "Paperback",
                    "Page Count": "352",
                    "Series": "Harry Potter"
                }
            else:
                mock_responses = {
                    "Author": "Unknown",
                    "Genre": "Unknown",
                    "Format (Hardcover, Paperback)": "Paperback",
                    "Page Count": "Unknown",
                    "Series": "Unknown"
                }
        else:
            # Generic fallback
            mock_responses = {attr: "Unknown" for attr in expected_attributes}
            # Try to extract some basic info
            if "brand" in [attr.lower() for attr in expected_attributes]:
                mock_responses["Brand"] = self._guess_brand(product_name)
        
        # Fill in expected attributes
        for attr in expected_attributes:
            if attr in mock_responses:
                attributes[attr] = mock_responses[attr]
            else:
                attributes[attr] = "Unknown"
        
        return attributes
    
    def _extract_model_from_name(self, product_name: str, prefix: str) -> str:
        """Extract model information from product name"""
        words = product_name.split()
        model_parts = []
        found_prefix = False
        
        for word in words:
            if prefix.lower() in word.lower():
                found_prefix = True
                model_parts.append(word)
            elif found_prefix and (word.isdigit() or any(char.isdigit() for char in word)):
                model_parts.append(word)
            elif found_prefix and word.lower() in ['pro', 'max', 'plus', 'mini', 'air']:
                model_parts.append(word)
        
        return ' '.join(model_parts) if model_parts else "Unknown"
    
    def _extract_storage(self, product_name: str) -> str:
        """Extract storage capacity from product name"""
        import re
        storage_match = re.search(r'(\d+)(gb|tb)', product_name.lower())
        if storage_match:
            return f"{storage_match.group(1).upper()}{storage_match.group(2).upper()}"
        return "Unknown"
    
    def _extract_ram(self, product_name: str) -> str:
        """Extract RAM from product name"""
        import re
        # Look for patterns like "8GB RAM" or "16GB"
        ram_match = re.search(r'(\d+)(gb|tb)(?:\s+ram)?', product_name.lower())
        if ram_match and int(ram_match.group(1)) <= 64:  # Reasonable RAM size
            return f"{ram_match.group(1)}GB"
        return "8GB"  # Default
    
    def _extract_color(self, product_name: str) -> str:
        """Extract color from product name"""
        colors = ['black', 'white', 'gray', 'grey', 'silver', 'gold', 'blue', 'red', 'green', 
                 'purple', 'pink', 'yellow', 'space gray', 'midnight', 'starlight']
        
        product_lower = product_name.lower()
        for color in colors:
            if color in product_lower:
                return color.title()
        return "Unknown"
    
    def _guess_brand(self, product_name: str) -> str:
        """Guess brand from product name"""
        brands = ['apple', 'samsung', 'google', 'sony', 'lg', 'nintendo', 'microsoft', 
                 'dell', 'hp', 'lenovo', 'asus', 'acer']
        
        product_lower = product_name.lower()
        for brand in brands:
            if brand in product_lower:
                return brand.title()
        return "Unknown"
    
    async def generate_product_description(self, product_name: str, attributes: Dict) -> str:
        """Generate a mock product description"""
        known_attrs = {k: v for k, v in attributes.items() if v != "Unknown"}
        
        if known_attrs:
            attr_text = ", ".join([f"{k}: {v}" for k, v in list(known_attrs.items())[:3]])
            return f"Quality {product_name} with great features including {attr_text}. Perfect for daily use!"
        else:
            return f"Quality {product_name} available for sale. Contact for more details."
    
    async def suggest_price_range(self, product_name: str, attributes: Dict, category: str) -> Dict:
        """Generate mock price suggestions"""
        product_lower = product_name.lower()
        
        # Simple price estimation based on product type
        if "iphone" in product_lower:
            if "13" in product_name or "14" in product_name:
                return {"min_price": 400, "max_price": 800, "currency": "USD", "reasoning": "Based on iPhone resale values"}
            else:
                return {"min_price": 200, "max_price": 500, "currency": "USD", "reasoning": "Based on older iPhone models"}
        elif "samsung" in product_lower or "galaxy" in product_lower:
            return {"min_price": 300, "max_price": 700, "currency": "USD", "reasoning": "Based on Samsung Galaxy resale market"}
        elif "macbook" in product_lower:
            return {"min_price": 600, "max_price": 1200, "currency": "USD", "reasoning": "Based on MacBook resale values"}
        elif category == "Books & Media":
            return {"min_price": 5, "max_price": 25, "currency": "USD", "reasoning": "Typical used book prices"}
        else:
            return {"min_price": 10, "max_price": 100, "currency": "USD", "reasoning": "General second-hand item estimate"}